---
date: 2021-11-26
title: "정보보안기사&산업기사 필기 34장 요약 - 웹 보안 (애플리케이션 보안)"
subtitle: "정보보안기사 필기 34장 요약내용입니다."
categories: 보안기사
tags:
  - 정보보안
  - 정보보안산업기사
  - 기사

# 목차
toc: true  
toc_sticky: true 
---


\* 2020 조현준 정보보안기사 산업기사 필기 + 핵심기출 1200제 정보보안기사 & 산업기사 필기 교재를 기반으로 요약하였습니다.


## Section 34. 웹 보안 (애플리케이션 보안)

### 1. 스크립트 언어 분류와 특징

|**구분**|**서버 스크립트 언어**|**사용자 스크립트 언어**|
|:---:|---|---|
|종류|PHP, ASP, JSP 등|JS, VBscript|
|특징|- 서버에서 프로그램 처리<br>- 취약점이 서버에게 직접 영향을 줌|- 사용자 시스템에서 프로그램 처리<br>- 취약점이 개인 시스템에 영향을 줌|
|장점|- 데이터베이스와 연동이 쉬움<br>- 서버 내에 있는 파일에 접근이 용이|- 서버에 부하를 주지 않음|
|단점|- 서버에 부하를 줌|- 기능이 제한|

<br>

### 2. HTTP - Text Transfer Protocol

▶ **웹에서 웹 페이지를 가져오기 위해 어떻게 클라이언트-서버 프로그램이 작성될 수 있는지 정의**

#### 트랜잭션

**1. 요청 메시지**

- *메소드(Method)* : 요청 라인에 포함된 정보 

	→ *GET 방식* : 요청 데이터에 대한 인수를 URL(Uniform Resource Locator)에 포함시켜 전송 

	→ *POST 방식* : 바디 영역에 소켓을 이용하여 데이터를 전송. 최소한의 보안성을 유지 

- *요청 헤더 라인* 

	→ 추가적인 정보(Host, User-Agent, Referrer 등)를 클라이언트에서 서버로 보냄 

- *본체(Body)* ​

	→ 메소드가 PUT이나 POST일 때, 송신될 주석이나 웹사이트에 게시될 파일을 담고 있음

	→ GET 방식의 경우 요청 데이터가 없기 때문에 본체(Body)가 없음

​
**2. 응답 메시지**

- *상태 코드 필드 (Statusline에 포함)* : 세 자리 숫자로 요청의 상태를 정의 (404,500 등)

- *응답 헤더 라인* : 추가적인 정보(Contents-Type, Contents-Length 등)를 서버에서 클라이언트로 보냄 

<br>

### 3. SSL/TLS(Secure Socket Layer/Transport Layer Security)

→ **가장 많이 이용되고 있는 암호 통신 방법**

\- 대칭키 암호, 공개키 암호, 일방향 해시함수, 메시지 인증코드, 의사난수 생성기, 전자서명을 조합해서 안전한 통신을 수행

\- 특정 암호기술에 의존하지 않고 암호 스위트라는 개념에 의해 선택이 가능

\- SSL/TLS로 통신을 수행할 때 URL은 https://로 시작한다. 

#### 1) SSL/TLS 보안 서비스

##### [기밀성 서비스] 

\- DES, RC4와 같은 대칭키 암호화 알고리즘을 사용하여 제공

\- 비밀키는 handshake protocol을 통해 생성

##### [클라이언트와 서버 상호 인증] 

\- 연결 설정 과정에서 서로 간에 신뢰할 수 있도록 인증을 사용

\- 인증에는 RSA와 같은 비대칭 암호 알고리즘, DSS와 같은 전자서명 알고리즘과 X.509 공개키 인증서가 사용

##### [메시지 무결성 서비스]

\- 안전한 해시 알고리즘을 사용해서 메시지 인증코드를 만들어 메시지에 포함

\- 신뢰성 있는 통신 가능

#### 2) SSL/TLS 프로토콜

##### [Handshake 프로토콜]

\- Record 프로토콜에 대한 보안 매개변수를 제공

\- 암호 집합을 설정하고 키와 보안 매개변수를 제공

\- 클라이언트가 서버에 대해 그리고 서버가 클라이언트에 대해 인증(상호인증)

##### [Record 프로토콜]

\- 응용 계층으로부터 오는 데이터 뿐만 아니라 TLS의 상위 프로토콜로부터 오는 메시지를 전송

\- Record 프로토콜에서 오는 메시지는 보통 TCP인 전송 계층의 페이로드

##### [ChangeCipherSpec 프로토콜]

\- 암호학적 비밀을 신속하게 보내는 데 사용 

##### [Alert 프로토콜]

\- 비정상 조건을 알리는데 사용

##### [Heartbeat 프로토콜]

\- 프로토콜 개체의 가용성을 모니터링 할 때 사용하는 프로토콜

#### 3) 핸드셰이크 프로토콜 동작

​**단계1**

\- 프로토콜 버전, 세션 ID, 암호조합, 압축 방법, 초기 랜덤넘버를 포함

**​단계2**

\- 서버가 필요하다고 생각되면 인증서, 키 교환을 보내고 인증서를 요청

​**단계3**

\- 클라이언트는 요청된 인증서를 보냄(요청이 있을 경우)

\- 클라이언트는 키 교환을 보내고 클라이언트는 인증서에 대한 확인을 보낼 수 있음

**단계4** 

\- 암호 조합을 교환하고 핸드셰이크 프로토콜 종료

<br>

### 3. SSL 핸드셰이크 프로토콜 메시지 유형

|**메시지 유형**|**설명**|
|:---:|---|
|Hello_Request|서버가 클라이언트에게 협상의 시작을 요구하는 메시지|
|Client_Hello|클라이언트가 서버에 연결을 시작하거나 HelloRequest 메시지에 대한 응답|
|Server_Hello|Client_Hello 메시지에 대한 응답|
|Server_Certificate|선택된 cipher suite의 키 교환 알고리즘에 맞는 서버의 인증서를 보냄|
|Server_Key_Exchange|인증서를 보내지 않았거나, 보낸 인증서에 정보가 부족할 때 전송|
|Certificate_Request|클라이언트의 인증서를 요청(선택적 요청, 요청 시 상호 인증이 이루어짐)|
|Server_Hello_Done|서버가 보낼 메시지가 끝났다고 알리는 메시지|
|Client_Certificate|서버가 클라이언트의 인증을 요구할 경우 클라이언트가 보내는 메시지|
|Client_Key_Exchange|세션키를 생성하기 위해 48bytes의 비밀 정보를 생성하고 공개키 알고리즘을 사용하여 pre_master_secret를 서버와 공유|
|Certificate_Verify|클라이언트 인증서의 명백한 확인을 위해 handshake 메시지를 전자서명하여 전송|
|Change_Cipher_Spec|이 메시지 이후에 전송되는 메시지는 새롭게 협상된 알고리즘과 키를 이용할 것임을 나타냄. (Handshake 프로토콜에 포함되지 않음)|
|Finished|- 협상된 알고리즘과 키가 처음으로 적용되고 상대편에서도 협상 결과를 이 메시지를 통해 확인하게 된다.<br>◦ 이 메시지를 마지막으로 handshake 수행을 마치고 데이터 전송이 시작된다.|

<br>

### 4. SSL/TLS에 대한 공격

- **OpenSSL의 HeartBleed 취약점** : 해당 취약점을 가진 OpenSSL 버전에서 Heartbeat 확장 기능에 요구 데이터 길이에 대한 점검이 없어서 다른 정보까지 상대방에게 전달될 수 있는 취약점.

- **POODLE 공격** : 공격자가 TLS를 SSL 3.0으로 다운그레이드 시켜 SSL 3.0의 취약점을 공격하는 기법

- **FREAK 공격** : SSL/TLS 서버가 RSA Export Suites라고 불리는 약한 암호 스위트를 사용하게 만드는 공격  

<br>

### 5. 웹 보안위협 및 보안대책

* OWASP TOP10(2017년)

|**구분**|**내용**|
|:---:|---|
|A1 - Injection (인젝션 취약점)|- SQL, OS, XXE, LDAP 인젝션 취약점은 신뢰할 수 없는 데이터가 명령어나 쿼리문의 일부분이 인터프리터로 보내질 때 발생<br>- 공격자의 악의적인 데이터는 예상하지 못하는 명령을 실행하거나 적절한 권한 없이 데이터에 접근하도록 인터프리터를 속일 수 있음|
|A2 - Broken Authentication (인증 취약점)|- 인증과 세션관리와 관련된 애플리케이션의 비정상적인 동작으로 인해 패스워드, 키, 세션 토큰 및 사용자 도용과 같은 취약점을 발생|
|A3 - Sensitive Data Exposure (민감 데이터 노출)|- 대부분의 웹 어플리케이션과 API는 금융정보, 개인정보, 건강정보와 같은 민감정보를 제대로 보호하지 않기 때문에, 개인정보 유출과 같은 취약점이 발생<br>- 브라우저에서 중요 데이터를 저장 또는 전송할 때 주의하고 암호화 같은 보호조치 취하기|
|A4 – XML External Entitles(XXE) (XML 외부 개체)|- 오래되거나 설정이 미흡한 XML 프로세서는 xML 문서 내에서 외부 개체 참조를 평가<br>- 외부 개체는 파일 URL 핸들러, 내부 파일 공우, 포트 검색, 원격 코드 실행 및 서비스 거부 공격을 사용하여 내부 파일을 노출 시키는데 사용될 수 있음|
|A5 - Broken Access Control (접근제어 취약점) |- 인증된 사용자가 수행할 수 있는 작업에 대한 제한이 제대로 적용되지 않을 때의 결 함을 악용하여 다른 사용자 계정에 접근하거나, 중요 데이터에 접근/수정, 접근 권한 변경할 수 있다. |
|A6 - Security Misconfiguration (보안 설정 오류) |- 어플리케이션, 프레임워크, WAS, 웹서버, DB 서버 및 플랫폼에 대한 보안설정을 적절 하게 구현 및 유지해야 한다. 또한 소프트웨어는 최신버전으로 유지하여야 한다. |
|A7 - XSS (크로스사이트스크립팅) |- 어플리케이션이 신뢰할 수 없는 데이터를 적절한 검증 없이 웹 브라우저로 전송하는 경우 발생. 공격자가 사용자 세션을 도용하거나, 웹사이트를 변조시키거나, 악성 사 이트로 리다이렉션 시킬 수 있다.| 
|A8 – Insecure Deserialization<br>(안전하지 않은 역직렬화) |- 원격 코드 실행으로 이어질 수 있으며, 권한 상승 공격, 인젝션 공격, 재생 공격 을 포함한 다양한 공격 수행에 사용될 수 있다. |
|A9 - Using Components with Known Vulnerabilities<br>(알려진 취약점이 있는 컴포넌트 사용) |- 어플리케이션과 같은 권한으로 실행되는 컴포넌트, 라이브러리, 프레임워크 등의 S/W 모듈은 취약한 컴포넌트를 악용하여 공격하는 경우 데이터 손실, 서버 권한 획 득과 같은 취약점을 가지고 있다. |
|A10 – Insufficient Logging&Monitoring<br>(불충분한 로깅 & 모니터링) |- 사고 대응의 비효율적인 통합 또는 누락이 공격자들로부터 시스템을 지속적으로 공 격할 수 있게 하거나 더 많은 시스템을 공격할 수 있도록 만들고, 데이터를 변조/유 출/삭제할 수 있게 한다.

<br>

### 6. SQL Injection 공격

▶ **데이터베이스와 연동되어 있는 애플리케이션의 입력 값을 조작하여 DBMS가 의도되지 않은 결과를 반환하도록 하는 공격 기법**

→ 전송되어 오는 입력 값에 대해 그 적정성을 검사하지 않았기 때문에 발생(필터링이 없을 경우)

#### 1) 종류

- *From SQL Injection* : HTML Form 기반 인증을 담당하는 해플리케이션의 취약점이 있는 경우 사용자 인증을 위한 쿼리문의 조건을 임의로 조작하여 인증을 우회하는 방법

- *Union SQL Injection* : union select 쿼리를 이용하여 한 쿼리의 결과를 다른 쿼리의 결과에 결합하여 공격하는 기법

- *Error-Based SQL Injection* : DB 쿼리에 대한 에러 값을 기반으로 한 단계씩 점진적으로 DB 정보를 획득할 수 있는 방법

- *Blind SQL Injection* : DB 쿼리에 대한 오류메시지를 반환하지 않으면 공격을 할 수 없는 Error-Based SQL Injection과 달리 오류 메시지가 아닌 쿼리 결과의 참과 거짓을 통해 의도하지 않은 SQL문을 실행함으로써 데이터베이스를 비정상적으로 공격하는 기법

​
#### 2) 보안 대책

- 사용자의 입력에 특수 문자가 포함되어 있는지 검증

- SQL 서버의 에러 메시지 미표시

- 일반 사용자 권한으로 시스템 저장 프로시저에 접근 불허

<br>

### 7. 사이트 간 스크립팅 (XSS, CSS, Cross Site Scripting)

▶ **공격자에 의해 작성된 스크립트가 다른 사용자에게 전달**

→ 다른 사용자의 웹 브라우저 내에서 적절한 검증 없이 실행되기 때문에 사용자의 세션을 탈취하거나, 웹 사이트를 변조하거나 혹은 악의적인 사이트로 사용자를 이동시킬 수 있다.

#### 1) 종류

- *StoredXSS* : 가장 일반적인 유형. 단순한 게시판 또는 자료실과 같이 사용자가 글을 저장할 수 있는 부분에 정상적인 평문 이 아닌 스크립트 코드를 입력하는 기법 

- *Reflected XSS* : 공격 스크립트가 포함된 공격 URL(사용자가 눈치 채지 못하게 인코딩)을 사용자가 클릭할 때 악성 스크립 트 코드가 서버 사이트에 의해 HTML 문서로 반사되어 웹 브라우저에서 실행시켜, 서버에 남기지 않고 공격을 수행 가능

#### 2) 보안 대책

- 사용자가 입력한 문자열의 <, >, &, " 등을 문자 변환 함수나 메소드를 사용하여 &It, &gt, &amp, &quot로 치환

- HTML 태그를 허용하는 게시판에서는 지원하는 HTML 태그의 리스트를 선정한 후, 해당 태그만 허용하는 방식을 적용

<br>

### 8. 사이트 간 요청 위조 (XSRF, CSRF, Cross Site Request Forgery)

▶ **특정 웹사이트에 대해 사용자가 인지하지 못한 상황에서 사용자의 의도와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 요청하게 하는 공격기법**

→ XSS 공격은 악성 스크립트가 클라이언트에서 실행되는 반면, CSRF 공격은 정상적인 사용자가 악성 스크립트를 서버에 요청

#### 보안 대책

- 입력화면 폼 작성 시 GET 방식보다는 POST 방식을 사용하고, 토큰을 이용하여 공격자의 직접적인 URL 사용이 동작하지 않도록 처리

- 특정한 사용자를 구분하는 인수가 있으면 하나의 사용자에게만 적용되거나 인증과정을 통해 공격 방어 가능 

<br>

### 9. 직접 객체 참조

▶ **파일, 디렉터리,DB 키와 같이 내부적으로 구현된 객체에 대한 참조가 노출될 때 발생**

→ **디렉터리 탐색 공격(파일 다운로드 취약점)** : 브라우저에서 확인 가능한 경로의 상위 디렉터리로 탐색하여 특정 시스템 파일을 다운로드하는 공격 방법

#### 보안 대책

- 파일 다운로드 전용 프로그램을 작성하여 사용할 때, ‘..’ 이나 ‘/’ 문자를 필터링 

- 파일 업로드 제한 부재 : 클라이언트에서 서버 측으로 임의의 파일을 보낼 수 있다는 것은 웹서버가 가질 수 있는 가장 치명적 인 취약점

- 첨부파일로 업로드하는 악성 코드는 대부분 웹셸

\> 따라서 업로드 가능한 파일의 확장자를 화이트리스트 방식으로 필터링 

<br>

### 10. 기존 방화벽 VS 웹 방화벽

* **웹 방화벽(WAF, Web Application Firewall)** 

	→ 웹 어플리케이션을 대상으로 시도되는 해킹을 차단해주는 솔루션 

#### 1) 기능 

\- **사용자 요청 검사** : 접근제어,WebDoS, 업로드 파일 및 요청 형식 검사,SQL 인젝션 및 XSS 등의 차단 

\- **콘텐츠 보호** : 정보 유출 차단, 웹 변조 방지, 코드 노출 진단

\- **위장** : URL 정보 위장, 서버 정보 위장

#### 2) 기존 방화벽 VS 웹 방화벽

|**구분**|**웹 방화벽**|**기존 방화벽**|
|:---:|---|---|
|목적|유해 HTTP의 차단|유해 포트의 차단|
|동작 레벨|애플리케이션 레이어(7계층)|네트워크 레이어(3~4계층)|
|동작 방식|규칙 + 애플리케이션 로직|일련의 규칙에 의해 동작|